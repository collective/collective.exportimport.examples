from App.config import getConfiguration
from collective.exportimport.import_content import get_absolute_blob_path
from collective.exportimport.import_content import ImportContent
from plone import api
from plone.i18n.normalizer.interfaces import IURLNormalizer
from plone.namedfile.file import NamedBlobFile
from plone.namedfile.file import NamedBlobImage
from plone.uuid.interfaces import IUUIDGenerator
from Products.CMFPlone.utils import _createObjectByType
from urllib.parse import urlparse
from zope.annotation.interfaces import IAnnotations
from zope.component import getUtility

import logging
import os
import re
import simplejson as json
import transaction


logger = logging.getLogger(__name__)

# map old to new views
VIEW_MAPPING = {
    "atct_album_view": "album_view",
    "prettyPhoto_album_view": "album_view",
    "folder_full_view": "full_view",
    "folder_listing": "listing_view",
    "folder_summary_view": "summary_view",
    "folder_tabular_view": "tabular_view",
    "layout_view": "view",
}

PORTAL_TYPE_MAPPING = {
    "EasyForm": "Document",
}

REVIEW_STATE_MAPPING = {}

# types from the new site which are versioned
VERSIONED_TYPES = [
    "Document",
    "File",
    "Image",
    "Link",
]

FILTER_IMPORTED_TYPES = True

# types from the old site which are imported
IMPORTED_TYPES = [
    "Document",
    "Folder",
    "Link",
    "File",
    "Image",
    "News Item",
    "Event",
    "LRF",
    "LIF",
    "EasyForm",
]

# types from the old site
ALLOWED_TYPES = []

CUSTOMVIEWFIELDS_MAPPING = {
    "warnings": None,
}

DEFERRED_KEY = "exportimport.deferred"
DEFERED_FIELDS = ["_tile_data", "contacts", "fhnw_info_event", "_form_data"]


IMAGE_ITEM_TEMPLATE = {
    "@type": "Image",
    "allow_discussion": False,
    "changeNote": "",
    "contributors": [],
    "creators": ["admin"],
    "description": "",
    "effective": None,
    "exclude_from_nav": False,
    "expires": None,
    "is_folderish": None,
    "layout": "image_view",
    "links": [],
    "oes": None,
    "review_state": "inherit",
    "rights": "",
    "searchwords": [],
    "showinsearch": False,
    "subjects": ["autogenerated_content"],  # mark these items to find them later
    "version": "current",
    "versioning_enabled": True,
    "workflow_history": {},
}

RELATION_TEMPLATE = {
    "relationship": "preview_image_link",
}


class CustomImportContent(ImportContent):

    DROP_PATHS = ()

    DROP_UIDS = ()

    def __init__(self, *args, **kwargs):
        super(CustomImportContent, self).__init__(*args, **kwargs)

        self.urls_with_preview_image = {}

        self.items_without_parent = []

        # Here is also the place to handle additional data you get from
        # other files.
        # cfg = getConfiguration()
        # filepath = os.path.join(cfg.clienthome, "import", "manual_data.csv")
        # with open(filepath, "r") as f:
        #   <process this file here and store it on this object>

    def start(self):
        self.view_names_found = []

        # Disable versioning for contenttypes
        types_with_versioning = []
        portal_types = api.portal.get_tool("portal_types")
        for portal_type in VERSIONED_TYPES:
            fti = portal_types.get(portal_type)
            behaviors = list(fti.behaviors)
            if "plone.versioning" in behaviors:
                logger.info(f"Disable versioning for {portal_type}")
                behaviors.remove("plone.versioning")
                types_with_versioning.append(portal_type)
            fti.behaviors = behaviors

        # store contenttypes with versioning on portal object
        portal = api.portal.get()
        IAnnotations(portal)["types_with_versioning"] = types_with_versioning
        transaction.commit()

    def finish(self):
        # just to make sure that everything before is commited
        transaction.commit()

        logger.info("Starting to import preview images...")
        preview_image_relations = []
        added_preview_image_objs = []

        # add preview images and store relations on site
        for index, (url, image_value) in enumerate(
            self.urls_with_preview_image.items(), start=1
        ):
            path = urlparse(url).path
            obj_with_preview_image = api.content.get(path)

            if not obj_with_preview_image:
                logger.info(
                    f"Could not find object with path {path} during preview "
                    "image import"
                )
                continue

            if not index % 100:
                logger.info(f"Imported {index} items...")
                transaction.savepoint()

            obj, is_new = self.create_image_obj(
                obj_with_preview_image, image_value, index, prefix_id="preview"
            )

            if is_new:
                added_preview_image_objs.append(obj.absolute_url())

                if self.commit and not len(added_preview_image_objs) % self.commit:
                    self.commit_hook(added_preview_image_objs, index)

            # now let's create the relation
            new_relation = RELATION_TEMPLATE.copy()
            new_relation["from_uuid"] = obj_with_preview_image.UID()
            new_relation["to_uuid"] = obj.UID()
            preview_image_relations.append(new_relation)

        transaction.commit()
        logger.info("Finished importing preview images...")

        logger.info("Starting to store preview image relations to portal...")
        portal = api.portal.get()
        IAnnotations(portal)["preview_image_relations"] = preview_image_relations

        transaction.commit()
        logger.info("Finished storing preview image relations to portal...")

        # export content without parents
        if self.items_without_parent:
            try:
                data = json.dumps(self.items_without_parent, sort_keys=True, indent=4)
            except (ValueError, TypeError):
                with open("items_without_parent_error.json", "w") as f:
                    for item in self.items_without_parent:
                        json_item = json.dumps(item, sort_keys=True, indent=4)
                        f.write(json_item + "\n")

            number = len(self.items_without_parent)
            cfg = getConfiguration()
            filename = "content_without_parent.json"
            filepath = os.path.join(cfg.clienthome, filename)
            with open(filepath, "w") as f:
                f.write(data)
            msg = f"Saved {number} items without parent to {filepath}"
            logger.info(msg)
            api.portal.show_message(msg, self.request)

    def create_image_obj(self, container, image_value, index, prefix_id=None):
        # let's create a new image item
        new_item = IMAGE_ITEM_TEMPLATE.copy()
        new_item_uuid = getUtility(IUUIDGenerator)()

        filename = image_value.get("filename", "preview-image")
        new_filename = f"{prefix_id}_{filename}" if prefix_id else filename
        new_id = getUtility(IURLNormalizer).normalize(new_filename)

        new_item["@id"] = f"{container.absolute_url()}/{new_id}"
        new_item["UID"] = new_item_uuid
        new_item["id"] = new_id
        new_item["image"] = image_value
        new_item["parent"] = {
            "@id": f"{container.absolute_url()}",
            "@type": container.portal_type,
            "UID": container.UID(),
        }
        new_item["title"] = new_id
        new_item["language"] = container.language
        new_item["cutting_options"] = "default"
        new_item["exclude_from_nav"] = True

        # Reuse object instead of creating a new one if id exists already
        if new_id not in container:
            new = _createObjectByType(new_item["@type"], container, new_item["id"])
            obj = self.handle_new_object(new_item, index, new)
            is_new = True
        else:
            is_new = False
            obj = container[new_item["id"]]
        return obj, is_new

    def commit_hook(self, added, index):
        msg = f"Committing after {added} created items..."
        logger.info(msg)
        transaction.get().note(msg)
        transaction.commit()
        if self.items_without_parent:
            data = json.dumps(self.items_without_parent, sort_keys=True, indent=4)
            number = len(self.items_without_parent)
            cfg = getConfiguration()
            filename = f"content_without_parent_{index}.json"
            filepath = os.path.join(cfg.clienthome, filename)
            with open(filepath, "w") as f:
                f.write(data)
            msg = f"Saved {number} items without parent to {filepath}"
            logger.info(msg)

    def global_dict_hook(self, item):
        if FILTER_IMPORTED_TYPES and item["@type"] not in IMPORTED_TYPES:
            return None

        if item.get("review_state", None) in ["trash"]:
            return None

        # update constraints
        if item.get("exportimport.constrains"):
            types_fixed = []
            for portal_type in item["exportimport.constrains"]["locally_allowed_types"]:
                if portal_type in PORTAL_TYPE_MAPPING:
                    types_fixed.append(PORTAL_TYPE_MAPPING[portal_type])
                elif portal_type in ALLOWED_TYPES:
                    types_fixed.append(portal_type)
            item["exportimport.constrains"]["locally_allowed_types"] = list(
                set(types_fixed)
            )

            types_fixed = []
            for portal_type in item["exportimport.constrains"][
                "immediately_addable_types"
            ]:
                if portal_type in PORTAL_TYPE_MAPPING:
                    types_fixed.append(PORTAL_TYPE_MAPPING[portal_type])
                elif portal_type in ALLOWED_TYPES:
                    types_fixed.append(portal_type)
            item["exportimport.constrains"]["immediately_addable_types"] = list(
                set(types_fixed)
            )

        # Layouts...
        if item.get("layout") in VIEW_MAPPING:
            new_view = VIEW_MAPPING[item["layout"]]
            if new_view:
                item["layout"] = new_view
            else:
                # drop unsupported views
                item.pop("layout")

        # Workflows...
        if item.get("review_state") in REVIEW_STATE_MAPPING:
            item["review_state"] = REVIEW_STATE_MAPPING[item["review_state"]]

        # Expires before effective
        effective = item.get("effective", None)
        expires = item.get("expires", None)
        if effective and expires and expires <= effective:
            item.pop("expires")

        # drop empty creator
        item["creators"] = [i for i in item.get("creators", []) if i]

        # set all items with a language attribe to avoid deserialisation
        # errors from plone.restapi
        if "language" in item:
            if item["language"] == "":
                item["language"] = None
        else:
            logger.warning(
                "NoLanguage: Item has no language field: {}".format(item["@id"])
            )

        # prepared deferred data
        item[DEFERRED_KEY] = {}

        # convert old types to new types
        if item["@type"] == "EasyForm":
            item["@type"] = "Document"

            # Extract and store relevant form fields
            form_data = {
                "fields_model": item.get("fields_model"),
                "actions_model": item.get("actions_model"),
                "thankstitle": item.get("thankstitle"),
                "thanksdescription": item.get("thanksdescription"),
                "thanksPrologue": item.get("thanksPrologue"),
                "thanksEpilogue": item.get("thanksEpilogue"),
                "formPrologue": item.get("formPrologue"),
                "formEpilogue": item.get("formEpilogue"),
                "submitLabel": item.get("submitLabel"),
                "resetLabel": item.get("resetLabel"),
                "formActionOverride": item.get("formActionOverride"),
                "enable_form_data_storage": item.get("enable_form_data_storage"),
                "forceSSL": item.get("forceSSL"),
                "onDisplayOverride": item.get("onDisplayOverride"),
                "afterValidationOverride": item.get("afterValidationOverride"),
                "thanksPageOverrideAction": item.get("thanksPageOverrideAction"),
                "thanksPageOverride": item.get("thanksPageOverride"),
                "form_tabbing": item.get("form_tabbing"),
                "show_titles": item.get("show_titles"),
                "recipients": item.get("recipients"),
                "send_confirmation": item.get("send_confirmation"),
                "confirmation_recipients": item.get("confirmation_recipients"),
                "subject": item.get("msg_subject"),
                "sender": item.get("senderOverride"),
                "sender_name": item.get("recipient_name"),
                "data_wipe": item.get("data_wipe"),
                "enableFormsAPI": item.get("enableFormsAPI"),
                "form_fields_order": item.get("form_fields_order"),
                "show_cancel": item.get("show_cancel"),
                "cancel_label": item.get("cancel_label"),
                "queryParameterName": item.get("queryParameterName"),
                "maxLength": item.get("maxLength"),
                "minLength": item.get("minLength"),
                "required": item.get("required"),
                "values": item.get("values"),
                "factory": item.get("factory"),
                "accept": item.get("accept"),
                "mail_header": item.get("mail_header"),
                "mail_footer": item.get("mail_footer"),
            }

            item[DEFERRED_KEY]["_form_data"] = form_data

        # remove empty subjects and convert StopSign subject to stop_sign field
        subjects = item.get("subjects", [])
        new_subjects = [subject for subject in subjects if subject]
        item["subjects"] = new_subjects

        item = convert_and_pop_field(item, "old_field_name", "new_field_name")

        if effective := item.get("effective"):
            item["effective"] = effective
        if expires := item.get("expires"):
            item["expires"] = expires

        image = item.get("image")
        if image and item.get("@type", "") != "Image":
            item.pop("image")
            self.urls_with_preview_image[item["@id"]] = image

        item["workflow_history"] = {}
        # removed layout so views work on the new site
        if "layout" in item:
            item.pop("layout")
        if "contentLayout" in item:
            item.pop("contentLayout")
        if "customContentLayout" in item:
            item.pop("customContentLayout")
        if "pageSiteLayout" in item:
            item.pop("pageSiteLayout")
        if "sectionSiteLayout" in item:
            item.pop("sectionSiteLayout")

        # Move deferred values to a different key to not deserialize.
        for fieldname in DEFERED_FIELDS:
            if item.get(fieldname):
                item[DEFERRED_KEY][fieldname] = item.pop(fieldname)
        return item

    def global_obj_hook(self, obj, item):
        deferred = item.get(DEFERRED_KEY, {})
        if deferred:
            annotations = IAnnotations(obj)
            annotations[DEFERRED_KEY] = {}
            for key, value in deferred.items():
                annotations[DEFERRED_KEY][key] = value
        return obj

    def dict_hook_collection(self, item):
        old_fields = item.get("customViewFields", [])
        fixed_fields = []
        for field in old_fields:
            if field in CUSTOMVIEWFIELDS_MAPPING:
                if CUSTOMVIEWFIELDS_MAPPING.get(field):
                    fixed_fields.append(CUSTOMVIEWFIELDS_MAPPING.get(field))
            else:
                fixed_fields.append(field)
        if fixed_fields:
            item["customViewFields"] = fixed_fields

        item["query"] = fix_collection_query(item.pop("query", []))

        if not item["query"]:
            logger.info(f"Drop collection without query: {item['@id']}")
            return

        return item

    def import_blob_paths(self, new, item):
        for key, value in item.items():
            # Look for dictionaries with a blob_path key.
            if not isinstance(value, dict):
                continue
            blob_path = value.get("blob_path")
            if not blob_path:
                continue
            abs_blob_path = get_absolute_blob_path(new, blob_path)
            if not abs_blob_path:
                # continue
                # __traceback_info__ = item
                raise ValueError(f"Blob path {blob_path} does not exist!")

            # Determine the class to use: file or image.
            filename = value["filename"]
            content_type = value["content-type"]
            if key == "file":
                klass = NamedBlobFile
            elif key == "image":
                klass = NamedBlobImage
            elif content_type.startswith("image"):
                klass = NamedBlobImage
            else:
                klass = NamedBlobFile

            # Write the field.
            with open(abs_blob_path, "rb") as myfile:
                blobdata = myfile.read()
            field_value = klass(
                data=blobdata,
                contentType=content_type,
                filename=filename,
            )
            setattr(new, key, field_value)


def convert_and_pop_field(item, old_field, new_field):
    if old_field in item:
        item[new_field] = item.pop(old_field)
    return item


def fix_collection_query(query):
    fixed_query = []

    indexes_to_fix = [
        "portal_type",
        "review_state",
        "Creator",
        "Subject",
    ]
    operator_mapping = {
        # old -> new
        "plone.app.querystring.operation.selection.is": "plone.app.querystring."
        "operation.selection.any",
        "plone.app.querystring.operation.string.is": "plone.app.querystring."
        "operation.selection.any",
    }
    extra_criteria = []
    if query is None:
        return query

    for crit in query:
        keep = True

        if crit["i"] == "portal_type" and "v" in crit and len(crit["v"]) > 30:
            # Criterion is all types
            continue

        # try to convert uuids to paths if possible.
        if crit["o"].endswith("absolutePath") and "v" in crit:
            # thanks github copilot for generating this pattern :)
            uuid_query_pattern = r"^[0-9a-fA-F]{32}::[-+]?\d+$"
            if re.match(uuid_query_pattern, crit["v"]) is not None:
                # ok now we now it's the pattern we expect
                uuid, depth = crit["v"].split("::")

                # we cant use the plone.app.uuid.utils methods because they are
                # using the catalog which is not up-to-date in any case.
                obj = api.content.get(UID=uuid)
                if obj:
                    path = obj.absolute_url_path().replace("/Plone", "")
                    crit["v"] = f"{path}::{depth}"

        if crit["o"].endswith("relativePath") and "v" in crit and crit["v"] == "..":
            # relativePath no longer accepts ..
            crit["v"] = "..::1"

        if crit["i"] == "classifiers_themes" or crit["i"] == "classifiers_categories":
            keep = False

        if crit["i"] in indexes_to_fix:
            for old_operator, new_operator in operator_mapping.items():
                if crit["o"] == old_operator:
                    crit["o"] = new_operator

        if crit["i"] == "portal_type":
            # Some types may have changed their names
            fixed_types = []
            if "v" in crit:
                for portal_type in crit["v"]:
                    fixed_type = PORTAL_TYPE_MAPPING.get(portal_type, portal_type)

                    # We have to ad
                    if fixed_type == "EasyForm":
                        fixed_type = "Document"

                    if isinstance(fixed_type, list):
                        fixed_types.extend(fixed_type)
                    else:
                        fixed_types.append(fixed_type)
            if "v" in crit and len(crit["v"]) == 1:
                portal_type = crit["v"][0]
                subjects = []
                if subjects:
                    # Add extra criterion.
                    extra_criteria.append(
                        {
                            "i": "subjects",
                            "o": "plone.app.querystring.operation.selection.any",
                            "v": subjects,
                        }
                    )
            crit["v"] = list(set(fixed_types))

        if crit["i"] == "review_state":
            # Review states may have changed their names
            fixed_states = []
            if crit["v"]:
                for review_state in crit["v"]:
                    fixed_state = {"trash": "private"}.get(review_state, review_state)
                    fixed_states.append(fixed_state)
            crit["v"] = list(set(fixed_states))

        if crit["o"] == "plone.app.querystring.operation.string.currentUser":
            crit["v"] = ""

        if keep:
            fixed_query.append(crit)

    # Add extra criteria, but only if this does not need merging with an existing one.
    for extra in extra_criteria:
        okay = True
        for crit in fixed_query:
            if crit["i"] == extra["i"]:
                okay = False
                break
        if okay:
            # There is no overlap so it is safe to add the extra criterion
            fixed_query.append(extra)

    return fixed_query


def get_defered_import_data(obj):
    annotations = IAnnotations(obj)
    return annotations.get(DEFERRED_KEY, {})
